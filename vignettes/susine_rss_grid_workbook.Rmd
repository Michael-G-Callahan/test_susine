---
title: "SuSiNE RSS Sensitivity Grid"
output:
  html_document:
    toc: true
    toc_depth: 2
    number_sections: true
editor_options:
  markdown:
    wrap: 72
---

```{r setup, message=FALSE}
library(dplyr)
library(tidyr)
library(purrr)
library(readr)
library(ggplot2)
library(tibble)
library(susine)

theme_set(theme_minimal())
```

# 1. Dummy inputs on disk

Small, deterministic inputs keep the workbook standalone. We write them
to a temp folder to mimic a file-driven workflow and immediately read
them back.

```{r dummy-inputs}
set.seed(42)
p <- 8
n <- 400
snp_ids <- paste0("snp", seq_len(p))

z_vec <- c(2.1, 1.5, 0.6, -0.2, 1.8, -1.1, 0.4, -0.6)
R_mat <- toeplitz(0.6 ^ (0:(p - 1)))
annotations_vec <- c(0.9, 0.6, 0.25, 0.1, 1.3, 0.4, 0.2, 0.05)

input_dir <- file.path(tempdir(), "susine_rss_grid_inputs")
dir.create(input_dir, showWarnings = FALSE, recursive = TRUE)

write_csv(tibble(snp_id = snp_ids, z = z_vec),
          file.path(input_dir, "z_scores.csv"))

R_df <- as_tibble(R_mat)
names(R_df) <- snp_ids
R_df <- mutate(R_df, snp_id = snp_ids, .before = 1)
write_csv(R_df, file.path(input_dir, "R_ld.csv"))

write_csv(tibble(snp_id = snp_ids, annotation = annotations_vec),
          file.path(input_dir, "annotations.csv"))

input_dir
```

```{r load-inputs}
z_path <- file.path(input_dir, "z_scores.csv")
R_path <- file.path(input_dir, "R_ld.csv")
annotation_path <- file.path(input_dir, "annotations.csv")

z_tbl <- read_csv(z_path, show_col_types = FALSE)
z <- z_tbl$z
snp_ids <- z_tbl$snp_id

R_tbl <- read_csv(R_path, show_col_types = FALSE)
R <- as.matrix(select(R_tbl, -snp_id))
rownames(R) <- R_tbl$snp_id
colnames(R) <- names(R_tbl)[-1]

annotations_tbl <- read_csv(annotation_path, show_col_types = FALSE)
annotations_vec <- annotations_tbl$annotation

stopifnot(length(z) == nrow(R),
          length(z) == ncol(R),
          length(z) == length(annotations_vec))
```

# 2. Helper settings and utilities

```{r helpers}
L <- 3L
sample_size <- 500
var_y <- 1
s_hat <- rep(1, length(z))

sigma_grid <- seq(0.1, 0.4, by = 0.1)
annotation_scales <- seq(0, 1.2, by = 0.3)
baseline_sigma <- 0.2
baseline_scale <- 0

kl_bernoulli <- function(p, q, eps = 1e-9) {
  p <- pmin(pmax(p, eps), 1 - eps)
  q <- pmin(pmax(q, eps), 1 - eps)
  sum(p * log(p / q) + (1 - p) * log((1 - p) / (1 - q)))
}

last_finite <- function(x) {
  x <- x[is.finite(x)]
  if (!length(x)) return(NA_real_)
  tail(x, 1)
}
```

# 3. Fit the grid

We run `susine_rss` over the requested prior variance and annotation
scales. Priors are held fixed (`prior_update_method = "none"`) to isolate
the effect of the provided hyperparameters.

```{r fit-grid}
design_grid <- tidyr::crossing(
  sigma_0_2 = sigma_grid,
  annotation_scale = annotation_scales
)

fit_grid <- design_grid %>%
  mutate(
    mu_0 = map(annotation_scale, ~ .x * annotations_vec),
    fit = pmap(
      list(sigma_0_2, mu_0),
      function(s0, mu_vec) {
        susine::susine_rss(
          L = L,
          z = z,
          R = R,
          n = sample_size,
          var_y = var_y,
          s_hat = s_hat,
          mu_0 = mu_vec,
          sigma_0_2 = s0,
          prior_update_method = "none",
          verbose = FALSE
        )
      }
    ),
    elbo = map_dbl(fit, ~ last_finite(.x$model_fit$elbo)),
    sigma_2 = map_dbl(fit, ~ last_finite(.x$model_fit$sigma_2)),
    pips = map(fit, ~ tibble(snp_id = snp_ids, pip = .x$model_fit$PIPs))
  )
```

```{r baseline}
baseline_vec <- fit_grid %>%
  filter(abs(sigma_0_2 - baseline_sigma) < 1e-8,
         abs(annotation_scale - baseline_scale) < 1e-8) %>%
  pull(pips) %>%
  pluck(1) %>%
  arrange(factor(snp_id, snp_ids)) %>%
  pull(pip)

if (length(baseline_vec) != length(snp_ids)) {
  stop("Baseline fit missing; ensure the grid includes sigma_0_2 = 0.2 and annotation_scale = 0.")
}
```

# 4. ELBO surface

```{r plot-elbo, fig.width=8, fig.height=4}
elbo_plot <- fit_grid %>%
  ggplot(aes(x = annotation_scale, y = sigma_0_2, fill = elbo)) +
  geom_tile(color = "white") +
  scale_fill_viridis_c(option = "C") +
  labs(
    title = "ELBO across sigma_0_2 and annotation scale",
    x = "Annotation scale",
    y = expression(sigma[0]^2),
    fill = "Final ELBO"
  ) +
  geom_point(data = tibble(annotation_scale = baseline_scale,
                           sigma_0_2 = baseline_sigma),
             shape = 21, size = 3, fill = "white", color = "black")

elbo_plot
```

# 5. KL drift from the baseline

```{r kl-matrix}
kl_grid <- fit_grid %>%
  mutate(
    kl_to_baseline = map_dbl(
      pips,
      ~ kl_bernoulli(
        arrange(.x, factor(snp_id, snp_ids))$pip,
        baseline_vec
      )
    ),
    kl_from_baseline = map_dbl(
      pips,
      ~ kl_bernoulli(
        baseline_vec,
        arrange(.x, factor(snp_id, snp_ids))$pip
      )
    )
  )

kl_long <- kl_grid %>%
  select(sigma_0_2, annotation_scale, kl_to_baseline, kl_from_baseline) %>%
  pivot_longer(cols = starts_with("kl_"), names_to = "direction", values_to = "kl")

ggplot(kl_long, aes(x = annotation_scale, y = sigma_0_2, fill = kl)) +
  geom_tile(color = "white") +
  facet_wrap(~ direction, nrow = 1) +
  scale_fill_viridis_c(option = "A") +
  labs(
    title = "KL divergence vs baseline (both directions)",
    x = "Annotation scale",
    y = expression(sigma[0]^2),
    fill = "KL"
  ) +
  geom_point(data = tibble(annotation_scale = baseline_scale,
                           sigma_0_2 = baseline_sigma),
             shape = 21, size = 3, fill = "white", color = "black")
```

# 6. Which SNPs move the most?

```{r pip-drift}
baseline_tbl <- tibble(snp_id = snp_ids, baseline_pip = baseline_vec)

pip_long <- fit_grid %>%
  select(sigma_0_2, annotation_scale, pips) %>%
  unnest(pips) %>%
  left_join(baseline_tbl, by = "snp_id") %>%
  mutate(
    delta = pip - baseline_pip,
    abs_delta = abs(delta)
  )

top_changes <- pip_long %>%
  filter(!(abs(sigma_0_2 - baseline_sigma) < 1e-8 &
           abs(annotation_scale - baseline_scale) < 1e-8)) %>%
  group_by(sigma_0_2, annotation_scale) %>%
  slice_max(order_by = abs_delta, n = 3, with_ties = FALSE) %>%
  arrange(desc(abs_delta))

knitr::kable(top_changes, digits = 3)
```

```{r pip-heatmap, fig.width=9, fig.height=5}
ggplot(pip_long, aes(x = annotation_scale, y = snp_id, fill = delta)) +
  geom_tile(color = "white") +
  facet_wrap(~ sigma_0_2, nrow = 2) +
  scale_fill_gradient2(
    low = "#2c7bb6", mid = "white", high = "#d7191c", midpoint = 0
  ) +
  labs(
    title = "PIP shifts relative to baseline",
    x = "Annotation scale",
    y = "SNP",
    fill = "Delta PIP"
  )
```

# 7. Optional extra: PIP traces by SNP

```{r pip-lines, fig.width=9, fig.height=5}
pip_lines <- pip_long %>%
  mutate(
    sigma_0_2 = factor(sigma_0_2),
    snp_id = factor(snp_id, levels = snp_ids)
  )

ggplot(pip_lines, aes(x = annotation_scale, y = pip, color = sigma_0_2, group = sigma_0_2)) +
  geom_line() +
  facet_wrap(~ snp_id) +
  geom_hline(
    data = baseline_tbl,
    aes(yintercept = baseline_pip),
    linetype = "dashed",
    color = "grey50",
    inherit.aes = FALSE
  ) +
  labs(
    title = "PIP trajectories across the grid",
    x = "Annotation scale",
    y = "PIP",
    color = expression(sigma[0]^2)
  )
```

The workbook is self contained: it writes tiny input files, reloads
them, runs `susine_rss` on the specified grid, compares ELBO and KL to
the `sigma_0_2 = 0.2`, `annotation_scale = 0` baseline, and surfaces the
largest SNP-level shifts. Swap the input CSVs for real data to use this
as a lightweight sensitivity harness.
